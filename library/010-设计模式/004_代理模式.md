## 代理模式

代理模式(Proxy Design Pattern)在不改变原始类(或叫被代理类)代码的情况下，通过引入代理类来给原始类附加功能，代理模式常用在业务系统中开发一些非功能性需求，如:监控、统计、鉴权、限流、事务、幂等、日志等。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在在RPC、缓存等应用场景中。

![](E:\git\Study\library\010-设计模式\images\代理模式类图.png)

+ 代理类:是一个类，它实现了在创建代理类时指定的接口列表
+ 代理接口:是代理类实现的一个接口.
+ 代理实例:是代理类的一个实例。
+ 被代理类:通过代理附加功能的类被代理对象:被代理类的一个实例。

### 静态代理

所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。静态代理的代理类由程序员创建或工具在类加载前生成。

**Client.java: **使用代理

```java
package com.wyy.proxy;

public class Client {
    public static void main(String[] args) {
        IUserService userService = new ProxyUserServiceImpl(new UserService());
        userService.create();
    }
}
```

**IUserService.java:**代理接口，由目标类和代理实现

```java
package com.wyy.proxy;

public interface IUserService {
    public void create();
}

```

**ProxyUserServiceImpl.java:**代码类、拦截目标方法的调用

```java
package com.wyy.proxy;

public class ProxyUserServiceImpl implements IUserService {
    private UserService UserService = null;

    public ProxyUserServiceImpl(UserService userService) {
        this.UserService = userService;
    }

    @Override
    public void create() {
        System.out.println("Create方法被调用");
    }
}

```

**UserService.java:**目标类、被代理类

```java
package com.wyy.proxy;

public class UserService implements IUserService {
    @Override
    public void create() {
        System.out.println("注册用户...");
    }
}
```

### 动态代理

动态代理(Dyamic Proxy)，就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

#### JDK动态代理

JDK自从1.3版本开始，就引入了动态代理，可以动态创建代理类和代理实例，代理实例是代理类的一个实例。每个代理实例都有一个关联的调用处理程序对象，它可以实现接口InvocationHandler。通过其中一个代理接口的代理实例上的方法调用将被指派到实例的调用处理程序的Invoke 方法，并传递代理实例、识别调用方法的 java.1ang.reflect.nethod 对象以及包含参数的 object 类型的数组，调用处理程序以适当的方式处理编码的方法调用，并且它返回的结果将作为代理实例上方法调用的结果返回。

**Client.java**

```java
package com.wyy.jdkProxy;


public class Client {
    public static void main(String[] args) {
        IUserService userService = (IUserService)Factory.create(IUserService.class,new UserServiceImpl());
        userService.create();
    }
}
```

**Factory.java:**根据传入的接口class实例和对应的实现类实例生成代理对象

```java
package com.wyy.jdkProxy;

import org.springframework.cglib.proxy.Proxy;


public class Factory {
    public static  Object create(Class superClass,Object target){
        Handler handler = new Handler(target);
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[]{superClass},handler);
    }
}
```

参数：

+ ClassLoaderloader:定义代理类的类加载器
+ Class<?>[]interfaces:代理类要实现的接口列表
+ InvocationHandler h:指派方法调用的调用处理程序

**Handler.java:**调用处理器

```java
package com.wyy.jdkProxy;

import org.springframework.cglib.proxy.InvocationHandler;

import java.lang.reflect.Method;

public class Handler implements InvocationHandler {
    private Object targetObject = null;

    public Handler(Object targetObject) {
        this.targetObject = targetObject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Handler-->在目标方法被调用之前附加功能");
        Object object = null;
        try {
            object = method.invoke(targetObject, args);
            System.out.println("Handler---->目标方法成功执行之后附加功能");
        }catch (Throwable e){
            System.out.println("\"Handler---->目标方法抛出异常之后附加功能");
        }finally {
            System.out.println("\"Handler---->目标方法完成之后附加功能");
        }
        return object;
    }
}
```

参数:

+ Object proxy:当前正在调用的代理实例
+ Method method:代理实例上调用的接口方法的 Method 实例
+ 0bject[] args:方法调用时传入的参数，如果接口方法不使用参数，则为 null。基本类型的参数被包装在适当基本包装器类(如java.lang.Integer或java.lang.Boolean)的实例中。

返回值:

+ 如果接口方法声明的返回类型是基本类型，则此方法返回的值是对应包装类型的实例;否则，它一定是可赋值给声明的返回类型的类型。如果此方法返回的值为null 并且接口方法的返回类型是基本类型，则代理实例上的方法调用将抛出NulPointerException。否则，如果此方法返回的值与上述接口方法的声明返回类型不兼容，则代理实例上的方法调用将抛出ClassCastException。如果方法声明返回void，则该方法返回null。

注意:

+ 手动调用被代理的方法
+ 代理对象，不要在invoke方法中调用代理的toString方法，否则会被InvocationHandler拦截，再次调用InvocationHandler的invoke方法，从而抛出栈溢出异常

**IUserService.java:**接口，由目标类实现

```java
package com.wyy.jdkProxy;

public interface IUserService {
    public void create();
}
```

**UserServiceImpl.java:**目标类，被代理类

```java
package com.wyy.jdkProxy;

public class UserServiceImpl implements IUserService {
    @Override
    public void create() {
        System.out.println("注册用户...");
    }
}

```

### CGLib代理

JDK动态代理要求被代理对象至少实现一个接口，如果被代理对象没有实现接口，则需要通过字节码工具生成一个代理类(代理类继承了被代理类)，CGLib(ByteCode Generation Library)使用ASM生成代理类。

> ASM是一个通用的]ava字节码操作和分析框架。它可以用于修改现有类或直接以二进制形式动态生成类。

**Client.java:**

```java
package com.wyy.cglib;

public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = (UserServiceImpl)Factory.create(UserServiceImpl.class);
        userService.create();
    }
}
```

**Factory.java:**根据传入的接口名称和对应的实现类实例生成代理对象

```java
package com.wyy.cglib;

import org.springframework.cglib.proxy.Enhancer;

public class Factory {
    public static Object create(Class Superclass) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Superclass);
        enhancer.setCallback(new Interceptor());

        //动态生成代理对象
        return enhancer.create();
    }
}
```

**Interceptor.java:**调用拦截器，实现MethodInterceptor

```java
package com.wyy.cglib;

import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class Interceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object proxy, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {
        System.out.println("Interceptor--->方法调用前-----------------");
        System.out.println("方法调用前");
        Object result = methodProxy.invokeSuper(proxy, params);
        System.out.println("Interceptor--->方法调用后-----------------");
        return result;
    }
}
```

参数:

+ Object proxy:由CGLib动态生成的代理类实例Method method:代理类实例正在被调用的方法0bjectl params:方法参数列表

+ MethodProxy methodProxy:代理方法和被代理方法(父类方法)的包装

注意:

+ 以下调用将形成递归调用，最后抛出栈溢出异常

  //ERROR
  System.out.printIn(proxy.tostring());

  //ERROR
  return method.invoke(proxy,args);

**UserServiceImpl.java:**目标类，被代理类

```java
package com.wyy.cglib;

public class UserServiceImpl implements IUserService {
    @Override
    public void create() {
        System.out.println("注册用户...");
    }
}
```

