[TOC]
# 四个特征
## 封装性
### 概念
封装性就是把类、类中的属性、方法、构造器、内部类这些内容使用访问控制符修饰，修饰之后我们就可以控制这些内容的访问权限。

| 角色 | public | protected | 不写 | private | 
|-------|-------|-------|-------|-------|
| 自己 | √ | √  |√  |√  |
| 同一个包的类  | √ | √ | √ | × |
| 不同包的子类  | √ | √ | × | × |
| 不同包的非子类 | √ | × | × | × |   

```
访问控制修饰符可以修饰类、类中属性、类中方法、类中构造器、类中内部类    
如果修饰类 只能使用public和默认权限这两种修饰符修饰 
属性、方法、构造器、内部类是可以被四种修饰符修饰的
```
### 应用
1. *** getter、setter方法（必须是公开的）***
    + 在声明好类的属性之后，我们可以通过对象名.属性名给属性进行赋值操作，但是如果直接给属性赋值，容易出现一些错误数据。为了解决这个问题，Java提出一个getter和setter方法用来解决这个问题
    + getter方法是Java的一种思维，思维就是获取属性值，不要通过属性直接获取，而是通过方法来获取。
    + setter方法是在给属性设置值的时候，不要直接对属性操作，而是通过一个setter方法实现对属性的赋值。
    + 使用getter和setter方法的时候，必须把属性私有化了。
2. *** 枚举类 ***

## 继承性
### 概念
```
一个类继承自一个父类，一旦继承成功，那么类就可以使用父类中的非私有化的属性和方法
在Java中，一个类只能有一个直接父类，但是可以多个间接父类
Java只支持单继承，但是Java支持多重继承。
A----B---C
继承语法：class  SonClass  extends  FaterClass{
}
在Java当中，如果一个类没有指定继承父类，那么这个类默认汇继承java.lang.Object类（超类）
```
```
代码块构造器执行之前自动执行的，代码块是在构造器的首行代码执行完成之后，构造器执行之前执行的。
```
### 继承之后属性和方法的重名问题
属性重名之后，如果要使用自己类中属性，通过this.调用，如果使用父类中的同名属性，使用super.调用
```
子类可以继承父类的非私有化的方法，但是如果子类觉得父类的方法逻辑不符合子类的要求，子类可以对父类的方法进行重写。重写就是把父类的方法定义全部保留，把方法体全部改掉
```
```
什么样的方法可以构成方法重写？
1、必须满足子类和父类中都有这个方法的定义
2、必须满足子类方法和父类方法的形参列表完全一致
3、子类方法的返回值一般必须和父类方法的返回值保持一致,子类方法返回值必须是父类方法返回值的子类
```
### 调用父类方法和属性的问题
+ 子类继承父类之后，可以直接使用父类的属性和方法，属性和方法在使用的时候，都是现在内存中声明定义出来才能使用。
+ 子类之所以可以使用父类的属性和方法，是因为子类在构建对象的时候会把父类对象也默认创建一份
+ 子类创建父类对象的过程是在子类构造器中完成的
+ 子类构造器首行如果没有声明super(),this()的时候，构造器首行会默认加上一行super()  super()就代表的是调用父类的无参构造器创建父类对象的。创建出来的父类对象，会被子类对象的一个属性引用，super
+ 如果父类没有无参构造器或者父类的无参构造器是私有化的，那么我们必须手动显示的在子类构造器的首行通过super(实参)的形式调用父类的其他构造器
+ 子类构造器中如果要使用父类的构造器，那么必须把父类构造器的调用声明在子类构造器的首行
+ this(实参列表)代表调用本类的其他构造器，super（实参列表）调用父类的构造器，这两个都必须声明在构造器的首行。因此构造器中如果使用了this()调用本类的其他构造器，那就不能再使用super（）调用父类的构造器了
+ 在一个类中，如果声明了N个构造器，那么最少有一个构造器的首行使用super(实参列表)调用了父类的构造器。最多有n-1个构造器使用了this(实参列表)调用了本类的其他构造器
## 多态性
多态是在继承体系下出现的一种概念。多态控制引用数据类型之间类型转换的，但是类型转换的前提是继承，两个类之间只要有了父子关系才能多态
### 多态的使用
#### 向上转型：一定可以成功的
```
Father t = new Son();
编译时类型和运行时类型具备父子关系的
将子类的引用给了父类对象，可以自动完成，不需要我们做任何处理。
```
#### 向下转型
```
Son s = (Son) new Father();
强转也可能会报错
将父类的引用给了子类对象，不能自动完成，需要我们强转，但是一定一定要注意，强转在某些情况下会报错。当父类的引用的运行时类型不是子类对象或者是子类对象的子类时，一定会报错
如果我们确实想要使用向下转型，那么最好在向下转型之前先使用instanceof判断父类的运行时类型是不是你要向下转型的类型 如果是 再转型，不是 就不是。
```
#### 获取或者判断一个对象的运行时类型
+ 获取某个对象的运行时类型: 对象名.getClass();
+ 判断某个对象的运行时类型是不是我们想要的某个类的类型instanceof : 对象名  instanceof  类名
### 引用数据类型变量声明以及初始化时的赋值符号两边的含义
```
数据类型 变量名 =  new  数据类型();
=左边叫做编译时类型
=右边叫做运行时类型
编写代码的时候，变量能调用哪些属性和方法看编译时类型。
运行代码的时候，方法的调用看的是=号右边的运行时类型。属性类型还是用的是编译时类型中属性值
多态只有方法的多态，没有属性的多态。
```
## 抽象性
### 抽象类
类本身是一类事物的抽象表示，抽象类也是类，只不过和类的区别在于抽象类太抽象，抽象到了没有一个具体的实例能真正的表示这个类    
从代码角度理解，不能创建对象的类称之为抽象类
```
访问控制修饰符  abstract  class  ClassName  [extends FatherClass  implements FatherInterface]{
     类体（属性、方法、构造器、代码块、内部类、抽象方法）
}
```
一般抽象类都有要求，抽象类就是专门设计用来让子类继承的。    
【注意】抽象类不能构建对象，但是抽象类可以有构造器的，构造器不是给我们构建对象使用的，是给抽象类的子类使用。
### 抽象方法
没有方法体的方法称之为抽象方法。
```
声明语法：
访问控制修饰符  abstract 返回值类型   方法名(形参列表);
```
抽象方法本来的含义就是让子类重写的。因此一旦有一个非抽象子类继承抽象类，那么强制性要求必须把抽象类中的抽象方法给重写了。    
抽象方法只能声明在抽象类中，抽象类不一定非得有抽象方法  
如果某一个父类已经把抽象类中抽象方法给重写了，那么子类就不需要再重写抽象方法了。
### 接口
java中继承是单继承，一个类只能有一个直接父类，Java接口是用来弥补Java单继承的缺陷的。Java接口是可以多实现的。一个子类可以实现多个接口。  
```
接口声明语法：
访问控制修饰符    interface   接口名  [extends 父接口]{
      接口的组成成分：
            抽象方法--JDK1.0
            静态方法（static修饰的方法）--JDK1.8
            静态常量属性（static final修饰的属性）--JDK1.0
            默认方法（default关键字修饰的方法）--JDK1.8
}
```
接口必须声明在.java文件中，.java文件的文件名就是接口名
```
接口如何使用？接口存在的意义就是让子类去实现的。
class Son implements FatherInterface,F1{

}
一旦非抽象子类实现了接口，那么必须重写接口中抽象方法
```
接口也满足多态的使用规则    
接口不能实现接口，但是接口可以继承接口