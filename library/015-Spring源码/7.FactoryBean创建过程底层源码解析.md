## 7.FactoryBean创建过程底层源码解析



### FactoryBean

```java
@Component
public class WYYFactoryBean implements FactoryBean {  // &wYYFactoryBean:WYYFactoryBean对象,wYYFactoryBean:UserService对象
    //BeanDefinition:1个

	@Override
	public Object getObject() throws Exception {
        UserService userService = new UserService();
		return userService;
	}

	@Override
	public Class<?> getObjectType() {
		return UserService.class;
	}
}
```

### 过程

finishBeanFactoryInitialization(beanFactory) 是 Spring 容器启动流程中从配置元数据到实际对象实例的转折点。它的核心任务是：**实例化所有非懒加载的单例 Bean，完成依赖注入，并执行生命周期回调方法。**

1. **入口**：AbstractApplicationContext.refresh() -> finishBeanFactoryInitialization(beanFactory)

2. **核心调用**：beanFactory.preInstantiateSingletons()

3. **最终目标**：将所有在之前步骤中注册好的、非抽象的、单例的、非懒加载的 BeanDefinition 转化为实实在在的 Java 对象，并放入单例池（Singleton Registry）中。

#### **详细流程分解**

**步骤 1：调用 finishBeanFactoryInitialization**

```java
// AbstractApplicationContext.java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // ... 其他初始化 (如 ConversionService, LoadTimeWeaverAware 等)
    // 核心：实例化所有非懒加载的单例bean
	beanFactory.preInstantiateSingletons();
 }
```



​	**步骤 2：DefaultListableBeanFactory.preInstantiateSingletons**
这个方法会：

1. 遍历所有已注册的 beanNames：获取容器中所有 BeanDefinition 的名称列表。

2. 对每个 beanName，获取其合并后的 RootBeanDefinition。

**步骤 3：获取合并的 RootBeanDefinition**

+ 为什么需要合并？ Spring 支持 BeanDefinition 的继承（通过 parent 属性）。一个 BeanDefinition 可能从它的父定义中继承属性。

+ 合并过程：getMergedLocalBeanDefinition(beanName) 方法会递归地合并当前 BeanDefinition 及其所有父定义的属性，最终生成一个 RootBeanDefinition 对象。

+ RootBeanDefinition 表示一个完整的、不能再被合并的 Bean 定义，它包含了创建 Bean 实例所需的全部信息。

+ 抽象 Bean：如果 BeanDefinition 被标记为 abstract="true"，则它不会被实例化，它的存在只是为了作为其他 BeanDefinition 的父模板。

**步骤 4：判断是否需要实例化**
对于每个 Bean，检查其 RootBeanDefinition：

+ 不是抽象的 (abstract=false)

+ 是单例的 (scope=singleton)

+ 不是懒加载的 (lazy-init=false)

如果满足以上所有条件，则进入实例化流程。

**步骤 5：区分普通 Bean 和 FactoryBean**
这是实例化过程中的一个关键分支。

1. **普通 Bean (如 UserService)**

调用链：preInstantiateSingletons() -> getBean(beanName) -> doGetBean(...) -> createBean(...) -> doCreateBean(...)

最终结果：通过反射调用构造函数创建一个 UserService 对象，完成属性填充和初始化后，将其放入单例池。

2. **FactoryBean (如 WYYFactoryBean)**

FactoryBean 是一个特殊的接口，它本身是一个能生产 Bean 的工厂。

+ FactoryBean 本身也是一个 Bean：Spring 会先创建 WYYFactoryBean 这个工厂对象。

+ 两个获取目标：
  + 获取 FactoryBean 本身：在 beanName 前加 & 前缀，即 getBean("&wYYFactoryBean")。
  + 获取 FactoryBean 生产的产品：使用普通的 beanName，即 getBean("wYYFactoryBean")，这会调用工厂的 getObject() 方法。

在 preInstantiateSingletons() 阶段，对于 FactoryBean：

+ 首先，会创建 WYYFactoryBean 工厂对象本身（因为它也是一个单例 Bean）。

+ 然后，检查这个 FactoryBean 是否实现了 SmartFactoryBean 接口，并且 isEagerInit() 方法返回 true。
  + 如果是，则在容器启动阶段就立即调用 getObject() 方法，创建其产品 Bean，并缓存起来。
  + 如果否（大部分普通 FactoryBean 都不是 SmartFactoryBean 或 isEagerInit()=false），则不会立即创建产品 Bean。产品 Bean 会在第一次被依赖注入或通过 getBean() 请求时才创建。

------

#### getBean -> doGetBean 的详细解析

当调用 getBean(beanName) 时，核心逻辑在 doGetBean 方法中。

```java
protected <T> T doGetBean(final String name, ...) throws BeansException {
    // 关键步骤1: 转换 beanName (处理 & 前缀和别名)
    final String beanName = transformedBeanName(name);
    // 关键步骤2: 尝试从单例缓存中获取 (解决循环依赖)
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null) {
        // 如果缓存中存在，直接返回 (对于FactoryBean，需要特殊处理)
        return (T) getObjectForBeanInstance(sharedInstance, name, beanName);
    }

    // 关键步骤3: 如果缓存中没有，开始创建Bean...
    // ... (创建Bean的复杂逻辑)
   } 
```


**关键细节 1: BeanName 转换 (transformedBeanName)**

+ 处理 FactoryBean 前缀 &：
  + 如果传入的 name 是 "&wYYFactoryBean"，transformedBeanName 会去掉 &，得到 beanName = "wYYFactoryBean"。
  + 如果传入的 name 是 "wYYFactoryBean"，beanName 也是 "wYYFactoryBean"。

+ 处理别名：如果 name 是一个别名，会解析出对应的规范名称（主名字）。

**关键细节 2: getObjectForBeanInstance - FactoryBean 产品获取**
这个方法决定了返回的是 FactoryBean 本身还是其产品：

```java
protected Object getObjectForBeanInstance(
        Object beanInstance, String name, String beanName) {
    // 如果name以&开头，表示要获取FactoryBean本身
    if (BeanFactoryUtils.isFactoryDereference(name)) {
        return beanInstance;
    }

    // 如果不是FactoryBean，直接返回实例
    if (!(beanInstance instanceof FactoryBean)) {
        return beanInstance;
    }

    // 如果是FactoryBean，并且name不是以&开头，则获取其getObject()返回的产品
    Object object = null;
    if (mbd == null) {
        // 尝试从缓存中获取FactoryBean创建的产品
        object = getCachedObjectForFactoryBean(beanName);
    }
    if (object == null) {
        // 缓存中没有，调用FactoryBean.getObject()创建产品
        FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
        object = getObjectFromFactoryBean(factory, beanName);
    }
    return object;
}
```

