## BeanDefinition扫描过程源码解析

1. BeanDefinition扫描过程底层原理源码解析
2. MetadataReader的作用和底层原理解析
3. ClassMetadata的作用和底层原理解析
4. AnnotationMetadata的作用和底层原理解析
5. ExcludeFilter的作用和底层原理解析
6. IncludeFilter的作用和底层原理解析
7. @ComponentScan注解解析过程底层源码解析
8. @Component注解解析过程底层源码解析
9. @Conditional注解解析过程底层源码解析
10. 静态内部类和内部类扫描过程底层源码解析
11. @Lookup注解的使用场景分析和底层原理解析
12. @Scope注解解析过程底层源码解析
13. 扫描过程中beanName重复处理过程底层源码解析
14. 一个类被重复扫描Spring处理流程底层源码解析

### BeanDefinition扫描过程底层原理

**步骤 1：调用 invokeBeanFactoryPostProcessors**

```java
// AbstractApplicationContext.java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    // 委托给 PostProcessorRegistrationDelegate 工具类来执行
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
}
```

**步骤 2：执行 BeanDefinitionRegistryPostProcessor**
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 方法内部的逻辑很复杂，但其核心是：

首先，找到所有实现了 BeanDefinitionRegistryPostProcessor 接口的处理器。

按照优先级排序（实现 PriorityOrdered -> 实现 Ordered -> 无优先级）。

依次调用它们的 postProcessBeanDefinitionRegistry(registry) 方法。

关键点：Spring 内置了一个非常重要的 BeanDefinitionRegistryPostProcessor —— ConfigurationClassPostProcessor。

**步骤 3：ConfigurationClassPostProcessor 开始工作**
这是整个流程的引擎。它的 postProcessBeanDefinitionRegistry 方法会：

识别配置类：在当前的 BeanDefinitionRegistry 中找出所有候选的“配置类”。通常，这就是被 @Configuration 标注的类。在 Spring Boot 中，主类上的 @SpringBootApplication 是一个组合注解，它包含了 @SpringBootConfiguration（其本身又被 @Configuration 标注），所以主类也是一个配置类。

解析配置类：使用 ConfigurationClassParser 来解析找到的配置类。

**步骤 4：ConfigurationClassParser 解析配置类**

解析器会递归地处理配置类上的所有注解，主要是：

@ComponentScan：这是我们关注的重点，它触发了组件扫描。（如果有多个，会扫描多次）

@Import：导入其他配置或 ImportSelector/ImportBeanDefinitionRegistrar。

@Bean：收集配置类中所有被 @Bean 标注的方法，将它们转化为 BeanDefinition。

**步骤 5：组件扫描的详细过程 (@ComponentScan)**
当解析器遇到 @ComponentScan 注解时，它会创建一个 ClassPathBeanDefinitionScanner（或复用已有的），并开始扫描过程。

创建扫描器 (new ClassPathBeanDefinitionScanner)

扫描器初始化时，会注册默认的过滤器：this.includeFilters.add(new AnnotationTypeFilter(Component.class));

这意味着，默认情况下，所有被 @Component 及其派生注解（如 @Service, @Repository, @Controller, @Configuration）标注的类都会被识别为候选组件。

配置扫描器 (doScan)

从 @ComponentScan 注解中读取用户自定义配置：

basePackages / value：指定要扫描的包路径。

basePackageClasses：通过类的包名来指定扫描路径。

nameGenerator：自定义 Bean 名称生成器。

scopeResolver：自定义作用域解析器。

scopedProxy：设置 ScopedProxyMode。

resourcePattern：自定义资源模式（默认是 "**/*.class"）。

includeFilters / excludeFilters：包含和排除过滤器。

lazyInit：是否延迟初始化。

确定扫描包路径

如果用户没有明确指定 basePackages，则使用声明 @ComponentScan 注解的配置类所在的包作为默认扫描路径。

开始扫描 (findCandidateComponents)

扫描策略：

索引扫描 (Indexed)：如果类路径下存在 META-INF/spring.components 文件（通常由 spring-context-indexer 在编译时生成），Spring 会使用索引来加速组件发现，避免类路径扫描。

传统扫描 (Classpath Scanning)：如果没有索引，则进行传统的类路径扫描。这也是最常见的方式。

传统扫描的过程：
a. 根据 basePackages 和 resourcePattern 找到所有 .class 文件，并将其封装为 Resource 对象。
b. 遍历每个 Resource，使用 ASM 技术读取类文件的字节码。为什么用 ASM？ 因为 ASM 不需要加载类（不触发类的初始化），效率高，且能避免某些类在类路径下但依赖缺失导致容器启动失败的问题。
c. 通过 ASM 解析出类的元数据（MetadataReader），包括注解信息、是否抽象、是否接口等。

过滤与判断 (isCandidateComponent)

使用配置的 includeFilters 和 excludeFilters 对解析出来的类进行过滤。

有黑名单，就先判断黑名单。不在黑名单内，就需要在白名单内，默认就支持@Component注解。在白名单内会继续判断是否符合@Conditional条件。

**核心条件：**

不能是接口或抽象类。

例外：如果是一个抽象类，但拥有 @Lookup 注解的方法，则它可以通过。

必须匹配至少一个 includeFilter 且不匹配任何 excludeFilter。

注册 BeanDefinition (registerBeanDefinition)
对于通过过滤的类，会将其转化为 ScannedGenericBeanDefinition。

设置作用域 (scope)：解析类上的 @Scope 注解，默认为 singleton。

生成 Bean 名称 (beanName)：使用 BeanNameGenerator（默认是 AnnotationBeanNameGenerator）生成 Bean 的名字。对于 @Component，通常取类名首字母小写。如果设置了自定义名称，则使用自定义名。

设置默认属性：解析其他注解，并为 BeanDefinition 设置相应属性：

@Lazy -> setLazyInit

@Primary -> setPrimary

@DependsOn -> setDependsOn

@Role -> setRole

@Description -> setDescription

检查冲突：检查 beanName 是否已经在 BeanFactory 中注册。如果已存在且不允许覆盖，则抛出 BeanDefinitionOverrideException。

处理代理模式 (ScopedProxyMode)：如果配置了 scopedProxy（例如在 Web 应用中常见的 @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)），Spring 不会直接注册目标 BeanDefinition，而是会创建一个 ScopedProxyFactoryBean 的 BeanDefinition 来包装它，以此实现作用域代理。

最终注册：将处理好的 BeanDefinition（可能是原始的，也可能是 ScopedProxy 的）包装成 BeanDefinitionHolder，然后调用 BeanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition) 将其正式注册到容器中。

### MetadataReader、ClassMetadata、AnnotationMetadata

在Spring中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以
Spring中对类的元数据做了抽象，并提供了一些工具类。

MetadataReader表示类的元数据读取器，默认实现类为SimpleMetadataReader。比如：

```java
SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory();
1
// 构造一个MetadataReader
MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader("com.wyy.service.UserService");
// 得到一个classMetadata，并获取了类名
ClassMetadata classMetadata = metadataReader.getClassMetadata();
System.out.println(classMetadata.getClassName());
//获取一个AnnotationMetadata，并获取类上的注解信息
AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadataO;
for (String annotationType : annotationMetadata.getAnnotationTypesO) {
	System.out.println(annotationType);
}
//假如类上使用的是@Component注解
System.out.println(annotationMetadata.hasAnnotation(Component.class.getName())); // true
System.out.println(annotationMetadata.hasMetaAnnotation(Component.class.getName())); // false
//如果是@Service
System.out.println(annotationMetadata.hasAnnotation(Component.class.getName())); // false
System.out.println(annotationMetadata.hasMetaAnnotation(Component.class.getName())); // true
```



### ExcludeFilter和lncludeFlter

这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示排除过滤器（相当于黑名单），IncludeFilter表示包含过滤器（相当于白名单）。

比如以下配置，表示扫描com.wyy这个包下面的所有类，但是排除UserService类，也就是就算它上面有
@Component注解也不会成为Bean。

```java
@ComponentScan(value ="com.wyy",excludeFilters={@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes =UserService.class)}.)
public class AppConfig {
}
```

再比如以下配置，就算UserService类上没有@Component注解，它也会被扫描成为一个Bean。

```java
@ComponentScan(value = "com.wyy",includeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = UserService.class)})
public class AppConfig {
}
```

FilterType包括以下几种类型：

1. ANNOTATION：验查是否包含特定注解。
2. ASSIGNABLE_TYPE：检查是否为特定类。
3. ASPECTJ：检查是否符合特定AspectJ 表达式。
4. REGEX：检查是否匹配特定正则表达式。
5. CUSTOM：自定义过滤条件。

在Spring的扫描逻辑中，默认会添加一个AnnotationTypeFilter给includeFilters，表示默认情况下Spring扫描过程中会认为类上有@Component注解的就是Bean。

Spring启动的时候会进行扫描，会先调用org.springframework.context.annotation.ClassPathSca
nningCandidateComponentProvider#scanCandidateComponents(String basePackage)
扫描某个包路径，并得到BeanDefinition的Set集合。