## 8.Bean创建过程生命周期源码解析

1. @DependsOn注解工作的底层源码解析
2. Bean的作用域实现底层源码解析
3. Spring类加载过程底层源码解析
4. Bean生命周期之实例化前底层源码解析
5. Bean生命周期之实例化底层源码解析
6. Bean生命周期之BeanDefinition后置处理底层源码解析
7. Bean生命周期之实例化后底层源码解析
8. Bean生命周期之Spring自动注入底层源码解析
9. Bean生命周期之属性处理底层源码解析
10. Bean生命周期之Aware回调底层源码解析
11. Bean生命周期之初始化前底层源码解析
12. Bean生命周期之初始化底层源码解析
13. Bean生命周期之初始化后底层源码解析



### Bean生命周期

#### 宏观流程总览

`preInstantiateSingletons()` 是 Spring 容器实例化所有非懒加载单例 Bean 的入口点，它通过 `getBean()` 方法触发 Bean 的创建过程，这个过程包含了复杂的依赖处理、循环依赖检测和实际的实例化逻辑。

------

#### 详细流程分解

##### 步骤 1：遍历与初始化

```java
// DefaultListableBeanFactory.java
public void preInstantiateSingletons() throws BeansException {
    // 获取所有已注册的bean名称
    List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
    
    for (String beanName : beanNames) {
        // 获取合并后的RootBeanDefinition
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        
        // 检查是否为非抽象、单例、非懒加载的Bean
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            // 如果是FactoryBean
            if (isFactoryBean(beanName)) {
                // 处理FactoryBean的逻辑
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                // ... 处理SmartFactoryBean的急切初始化
            } else {
                // 普通Bean的直接实例化
                getBean(beanName);
            }
        }
    }
}
```



##### 步骤 2：`getBean()` -> `doGetBean()` 的详细解析

```java
protected <T> T doGetBean(final String name, ...) {
    // 1. 转换beanName（处理&前缀、别名等）
    final String beanName = transformedBeanName(name);
    
    // 2. 尝试从单例缓存中获取（解决循环依赖的关键）
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null) {
        return (T) getObjectForBeanInstance(sharedInstance, name, beanName);
    }
    
    // 3. 检查父BeanFactory
    BeanFactory parentBeanFactory = getParentBeanFactory();
    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
        // 委托给父BeanFactory创建
        return parentBeanFactory.getBean(nameToLookup, requiredType);
    }
    
    // 4. 标记当前bean为创建中（用于循环依赖检测）
    if (!typeCheckOnly) {
        markBeanAsCreated(beanName);
    }
    
    try {
        // 5. 获取合并后的BeanDefinition
        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
        
        // 6. 检查BeanDefinition是否是抽象的
        if (mbd.isAbstract()) {
            throw new BeanIsAbstractException(beanName);
        }
        
        // 7. 处理@DependsOn依赖
        String[] dependsOn = mbd.getDependsOn();
        if (dependsOn != null) {
            for (String dep : dependsOn) {
                // 检查是否存在循环依赖
                if (isDependent(beanName, dep)) {
                    throw new BeanCreationException("Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                }
                // 注册依赖关系
                registerDependentBean(dep, beanName);
                // 先创建依赖的Bean
                getBean(dep);
            }
        }
        
        // 8. 根据Scope创建Bean实例
        if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -> {
                try {
                    return createBean(beanName, mbd, args);
                } catch (BeansException ex) {
                    destroySingleton(beanName);
                    throw ex;
                }
            });
            return (T) getObjectForBeanInstance(sharedInstance, name, beanName);
        } else if (mbd.isPrototype()) {
            // 原型作用域的创建逻辑
            // ...
        } else {
            // 其他自定义作用域的创建逻辑
            // ...
        }
    } catch (BeansException ex) {
        cleanupAfterBeanCreationFailure(beanName);
        throw ex;
    }
}
```



##### 步骤 3：依赖关系管理的深入解析

**依赖关系的数据结构：**

```java
// 这两个Map用于跟踪Bean之间的依赖关系
private final Map<String, Set<String>> dependentBeanMap = new ConcurrentHashMap<>();
private final Map<String, Set<String>> dependenciesForBeanMap = new ConcurrentHashMap<>();
```

**依赖关系的含义：**

- **`dependentBeanMap`**：
  - **Key**: `canonicalName`（被依赖的Bean）
  - **Value**: `Set<dependentBeanName>`（依赖该Bean的所有Bean）
  - **含义**: 记录了一个Bean被哪些其他Bean依赖
- **`dependenciesForBeanMap`**：
  - **Key**: `dependentBeanName`（依赖其他Bean的Bean）
  - **Value**: `Set<canonicalName>`（该Bean依赖的所有Bean）
  - **含义**: 记录了一个Bean依赖了哪些其他Bean

**示例说明：**

```java
// 假设有：A dependsOn B, A dependsOn C
// 那么：
dependentBeanMap: 
    B -> [A]
    C -> [A]

dependenciesForBeanMap:
    A -> [B, C]
```



##### 步骤 4：循环依赖检测 (`isDependent`)

```java
//判断beanName是不是被dependentBeanName依赖
protected boolean isDependent(String beanName, String dependentBeanName) {
    // 检查dependentBeanName是否已经依赖于beanName
    // 即检查是否存在：dependentBeanName -> ... -> beanName 的依赖链
    synchronized (this.dependentBeanMap) {
        return isDependent(beanName, dependentBeanName, null);
    }
}

private boolean isDependent(String beanName, String dependentBeanName, Set<String> alreadySeen) {
    // 如果已经检测过这个依赖链，避免无限递归
    if (alreadySeen != null && alreadySeen.contains(beanName)) {
        return false;
    }
    
    String canonicalName = canonicalName(beanName);
    //依赖beanName的Set
    Set<String> dependentBeans = this.dependentBeanMap.get(canonicalName);
    if (dependentBeans == null || dependentBeans.isEmpty()) {
        return false;
    }
    if (dependentBeans.contains(dependentBeanName)) {
        return true;
    }
    if (alreadySeen == null) {
        alreadySeen = new HashSet<>();
    }
    alreadySeen.add(beanName);
    for (String transitiveDependency : dependentBeans) {
        if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {
            return true;
        }
    }
    return false;
}
```



##### 步骤 5：@DependsOn 与属性注入循环依赖的区别

**@DependsOn 循环依赖：**

- **检测时机**：在 Bean 创建之前，通过静态分析依赖关系图
- **解决方式**：**无法解决**，直接抛出 `BeanCreationException`
- **原因**：`@DependsOn` 表示强制的初始化顺序依赖，循环依赖意味着矛盾的初始化要求

**属性注入循环依赖：**

- **检测时机**：在 Bean 实例化过程中，通过三级缓存机制
- **解决方式**：**可以解决**（对于单例、构造函数注入除外）
- **原因**：Spring 通过提前暴露对象引用（半成品Bean）来解决setter/field注入的循环依赖

##### 步骤 6：Bean 的最终创建

在处理好所有依赖关系后，进入实际的 Bean 创建流程：

1. **根据 Scope 选择创建策略**：
   - **单例**：使用 `getSingleton()` 方法，该方法内部会处理循环依赖
   - **原型**：每次创建新实例
   - **其他作用域**：如 request、session 等
2. **FactoryBean 的特殊处理**：
   - 如果是 FactoryBean，在 `getObjectForBeanInstance()` 中决定返回 FactoryBean 本身还是其 `getObject()` 方法返回的对象
   - 对于 `&beanName` 的请求，返回 FactoryBean 本身
   - 对于普通 `beanName` 的请求，返回 `factoryBean.getObject()` 的结果

##### 步骤 7：createBean

```
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
//args推断构造方法
// 加载类
		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
		先判断是否已经将全限定类名转化为Class对象，如果没有则进行加载。
		实例化前，如果返回了具体对象就不执行后续的生命周期步骤了
		resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)
```



### 加载类

要创建一个Bean对象，就必须得先保证类被加载了，而类加载就涉及到用哪个类加载器，ClassUtils.getDefaultClassLoader()体现了Spring选择ClassLoader的逻辑：

1. 优先返回当前线程中的ClassLoader
2. 线程中类加载器为null的情况下，返回ClassUtils类的类加载器
3. 如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器

### 实例化前

