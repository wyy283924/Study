## 9.Bean销毁过程生命周期源码解析

课程内容：

1. Bean销毁过程底层源码解析

2. DisposableBean接口工作流程底层源码解析
3. @PreDestroy注解工作流程底层源码解析
4. inferred机制工作流程底层源码解析
5. DestructionAwareBeanPostProcessor底层源码解析
6. 适配器设计模式在Bean销毁机制中的应用分析
7. 不同作用域下Bean销毁机制的底层源码解析
8. Spring容器关闭时触发Bean销毁过程底层源码解析



Bean销毁是发生在Spring容器关闭过程中的，在Spring容器关闭时，比如：

postProcessBeforeInitialization

LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());

buildLifecycleMetadata(beanClass);

判断是否有@Postconstruct,@PreDestory

```java
ReflectionUtils.doWithLocalMethods(currentClass, method -> {
				for (Class<? extends Annotation> initAnnotationType : this.initAnnotationTypes) {
					if (initAnnotationType != null && method.isAnnotationPresent(initAnnotationType)) {
						currInitMethods.add(new LifecycleMethod(method, beanClass));
						if (logger.isTraceEnabled()) {
							logger.trace("Found init method on class [" + beanClass.getName() + "]: " + method);
						}
					}
				}
				for (Class<? extends Annotation> destroyAnnotationType : this.destroyAnnotationTypes) {
					if (destroyAnnotationType != null && method.isAnnotationPresent(destroyAnnotationType)) {
						currDestroyMethods.add(new LifecycleMethod(method, beanClass));
						if (logger.isTraceEnabled()) {
							logger.trace("Found destroy method on class [" + beanClass.getName() + "]: " + method);
						}
					}
				}
			});

// 销毁Bean相关的逻辑 判断是否有销毁逻辑 适配器模式
registerDisposableBeanIfNecessary(beanName, bean, mbd);
```



```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);
//		applicationContext.register(MyConfig.class);
//		applicationContext.setAllowCircularReferences(false);
		applicationContext.refresh();

		AService aService = (AService) applicationContext.getBean("AService");
		applicationContext.close();
//      applicationContext.registerShutdownHook();//JVM要正常关闭
```

AutoCloseable

```java
userService实现AutoCloseable
    
	@Override
	public void close() throws Exception {
		System.out.println("b");
	}
```





```java
//在实现了MergedBeanDefinitionPostProcessor中添加
@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
		if("userService".equals(beanName)) {
			System.out.println("BeanDefinition的后置处理");
		beanDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
			beanDefinition.setInitMethodName("a");
			beanDefinition.setDestroyMethodNames("b");
		}
	}
在userService中添加b方法
```

将销毁方法名称写为(inferred),直接调用close()或者shutdown()方法

容器关闭

```
// 发布容器关闭事件
// 执行Lifecycle beans的close方法
把依赖它的bean都关闭
```
