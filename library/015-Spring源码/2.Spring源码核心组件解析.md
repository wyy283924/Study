## Spring 源码核心组件解析

1. 核心组件BeanDefination使用与底层解析
2. 核心组件BeanDefinationReader使用与底层解析
3. 核心组件AnnotatedBeanDefinitionReader使用与底层解析
4. 核心组件XmlBeanDefinitionReader使用与底层解析
5. 核心组件ClassPathBeanDefinitionScanner使用与底层解析
6. BeanDefination合并的使用与底层解析
7. 核心组件BeanFactory使用与底层解析
8. 核心组件DefaultListableBeanFactory使用与底层解析
9. 核心组件ApplicationContext使用与底层解析
10. ApplicationContext国际化功能的使用与底层解析
11. ApplicationContext资源加载功能的使用与底层解析
12. ApplicationContext获取运行时环境功能的使用与底层解析
13. ApplicationContext事件发布功能的使用与底层解析
14. 类型转化之PropertyEditor的使用与底层解析
15. 类型转化之ConversionService的使用与底层解析
16. 类型转化之TypeConvertor的使用与底层解析
17. Order比较器OrderComparator的使用与底层解析
18. Order比较器AnnotationAwareOrderComparator的使用与底层解析

**getBean**

```java
@SuppressWarnings("unchecked")
	@Override
	public <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {
		Assert.notNull(requiredType, "Required type must not be null");
		Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);
		if (resolved == null) {
			throw new NoSuchBeanDefinitionException(requiredType);
		}
		return (T) resolved;
	}
```

**resolveBean**

```java
@Nullable
	private <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {
		NamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);
		if (namedBean != null) {
			return namedBean.getBeanInstance();
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlbf) {
			return dlbf.resolveBean(requiredType, args, nonUniqueAsNull);
		}
		else if (parent != null) {
			ObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);
			if (args != null) {
				return parentProvider.getObject(args);
			}
			else {
				return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());
			}
		}
		return null;
	}
```

**resolveNamedBean**

```java
@SuppressWarnings("unchecked")
	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {

		Assert.notNull(requiredType, "Required type must not be null");
		String[] candidateNames = getBeanNamesForType(requiredType);

		if (candidateNames.length > 1) {
			List<String> autowireCandidates = new ArrayList<>(candidateNames.length);
			for (String beanName : candidateNames) {
				if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
					autowireCandidates.add(beanName);
				}
			}
			if (!autowireCandidates.isEmpty()) {
				candidateNames = StringUtils.toStringArray(autowireCandidates);
			}
		}

		if (candidateNames.length == 1) {
			return resolveNamedBean(candidateNames[0], requiredType, args);
		}
		else if (candidateNames.length > 1) {
			Map<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);
			for (String beanName : candidateNames) {
				if (containsSingleton(beanName) && args == null) {
					Object beanInstance = getBean(beanName);
					candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
				}
				else {
					candidates.put(beanName, getType(beanName));
				}
			}
			String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());
			if (candidateName == null) {
				candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());
			}
			if (candidateName != null) {
				Object beanInstance = candidates.get(candidateName);
				if (beanInstance == null) {
					return null;
				}
				if (beanInstance instanceof Class) {
					return resolveNamedBean(candidateName, requiredType, args);
				}
				return new NamedBeanHolder<>(candidateName, (T) beanInstance);
			}
			if (!nonUniqueAsNull) {
				throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
			}
		}

		return null;
	}
```

**getBeanNamesForType**

```java
@Override
	public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {
		if (!isConfigurationFrozen() || type == null || !allowEagerInit) {
			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);
		}
		Map<Class<?>, String[]> cache =
				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);
		String[] resolvedBeanNames = cache.get(type);
		if (resolvedBeanNames != null) {
			return resolvedBeanNames;
		}
		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);
		if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {
			cache.put(type, resolvedBeanNames);
		}
		return resolvedBeanNames;
	}
```

**doGetBeanNamesForType**

```java
private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
		List<String> result = new ArrayList<>();

		// Check all bean definitions.
		for (String beanName : this.beanDefinitionNames) {
			// Only consider bean as eligible if the bean name is not defined as alias for some other bean.
			if (!isAlias(beanName)) {
				try {
					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && (allowEagerInit ||
							(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
						BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();
						boolean matchFound = false;
						boolean allowFactoryBeanInit = (allowEagerInit || containsSingleton(beanName));
						boolean isNonLazyDecorated = (dbd != null && !mbd.isLazyInit());
						if (!isFactoryBean) {
							if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
						}
						else {
							if (includeNonSingletons || isNonLazyDecorated ||
									(allowFactoryBeanInit && isSingleton(beanName, mbd, dbd))) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
							if (!matchFound) {
								// In case of FactoryBean, try to match FactoryBean instance itself next.
								beanName = FACTORY_BEAN_PREFIX + beanName;
								if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
									matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
								}
							}
						}
						if (matchFound) {
							result.add(beanName);
						}
					}
				}
				catch (CannotLoadBeanClassException | BeanDefinitionStoreException ex) {
					if (allowEagerInit) {
						throw ex;
					}
					// Probably a placeholder: let's ignore it for type matching purposes.
					LogMessage message = (ex instanceof CannotLoadBeanClassException ?
							LogMessage.format("Ignoring bean class loading failure for bean '%s'", beanName) :
							LogMessage.format("Ignoring unresolvable metadata in bean definition '%s'", beanName));
					logger.trace(message, ex);
					// Register exception, in case the bean was accidentally unresolvable.
					onSuppressedException(ex);
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Bean definition got removed while we were iterating -> ignore.
				}
			}
		}

		// Check manually registered singletons too.
		for (String beanName : this.manualSingletonNames) {
			try {
				// In case of FactoryBean, match object created by FactoryBean.
				if (isFactoryBean(beanName)) {
					if ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {
						result.add(beanName);
						// Match found for this bean: do not match FactoryBean itself anymore.
						continue;
					}
					// In case of FactoryBean, try to match FactoryBean itself next.
					beanName = FACTORY_BEAN_PREFIX + beanName;
				}
				// Match raw bean instance (might be raw FactoryBean).
				if (isTypeMatch(beanName, type)) {
					result.add(beanName);
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Shouldn't happen - probably a result of circular reference resolution...
				logger.trace(LogMessage.format(
						"Failed to check manually registered singleton with name '%s'", beanName), ex);
			}
		}

		return StringUtils.toStringArray(result);
	}
```



### BeanDefinition

BeanDefinition是非常非常核心的一个概念，一个BeanDefinition表示一个Bean定义，Spring会根据BeanDefinition来创建具体的Bean对象。

BeanDefinition中有些常用的属性

+ beanClass: 表示Bean的类型
+ scope: 表示Bean的作用域，比如单例或多例
+ lazyInit:表示Bean是不是懒加载的
+ initMethodName:表示Bean初始化时要执行的方法
+ destoryMethodName:表示Bean销毁时要执行的方法
+ ……

当我们使用<bean/>、@Bean、@Component等方式定义Bean时，Spring底层就会解析这些标签和注解生成对应的BeanDefinition对象。

我们也可以通过代码的方式直接定义和注册BeanDefinition，比如：

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        
        BeanDefinition beanDefinition = new AnnotatedGenericBeanDefinition(UserService.class);
        beanDefinition.setScope("prototype");
        beanDefinition.setLazyInit(false);
        beanDefinition.setInitMethodName("a");

        applicationContext.registerBeanDefinition("userService",beanDefinition);
```

### BeanDefinitionReader


BeanDefinitionReader在我们使用Spring时用得少，但在Spring源码中用得多，相当于Spring源码的基础设施，顾名思义，BeanDefinitionReader是用来解析读取BeanDefinition对象的，主要有两个，一个是AnnotatedBeanDefinitionReader，另外一个是XmlBeanDefinitionReader。

### AnnotatedBeanDefinitionReader

作用是解析某个类上的注解信息从而得到BeanDefinition对象:

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

        AnnotatedBeanDefinitionReader beanDefinitionReader = new AnnotatedBeanDefinitionReader(applicationContext);
        beanDefinitionReader.register(UserService.class);

        System.out.println(applicationContext.getBean("userService"));
```

会解析类上的：@Conditional, @Scope、@Lazy、@Primary、@Fallback (Spring6新增的注解)、@DependsOn、@Role、@Description

### XmlBeanDefinitionReader

AnnotatedBeanDefinitionReader是用来解析类的，XmlBeanDefinitionReader是用来解析xml文件的

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext);
        beanDefinitionReader.loadBeanDefinitions("spring.xml");

        System.out.println(applicationContext.getBean("userService"));
```



### ClassPathBeanDefinitionScanner

ClassPathBeanDefinitionScanner是扫描器，@ComponentScan注解的底层实现就是用的它，它的作用是能对某个包路径进行扫描，从而得到BeanDefinitio对象，默认情况下，它只会把加了@Component注解的类生成对应的BeanDefinition对象。

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        applicationContext.refresh();
        
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(applicationContext);
        scanner.scan("com.wyy");

        System.out.println(applicationContext.getBean("userService"));
```

我们也可以自定义注解，并进行扫描

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface WYYComponent {
    String value() default "";
}
```

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        applicationContext.refresh();

        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(applicationContext);
        scanner.addIncludeFilter(new TypeFilter() {
            @Override
            public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
                return metadataReader.getAnnotationMetadata().hasAnnotation("WYYComponent");
            }
        });
        scanner.scan("com.wyy");

        System.out.println(applicationContext.getBean("userService"));
```

**BeanDefinition合并**

在后续看源码的过程中，Spring在利用BeanDefinition创建Bean对象时，会判断一个BeanDefinition是否存在父BeanDefinition，如果存在则先进行合并，就像父子类一样，子类会继承或覆盖父类的属性，子BeanDefinition会继承或覆盖父BeanDefinition的属性。

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        applicationContext.refresh();

        AnnotatedGenericBeanDefinition parentBeanDefinition = new AnnotatedGenericBeanDefinition(UserService.class);
        parentBeanDefinition.setScope("prototype");
        applicationContext.registerBeanDefinition("parentUserService",parentBeanDefinition);

        AnnotatedGenericBeanDefinition childBeanDefinition = new AnnotatedGenericBeanDefinition(UserService.class);
        childBeanDefinition.setParentName("parentUserService");
        applicationContext.registerBeanDefinition("childUserService",childBeanDefinition);
```

### BeanFactory和ApplicationContext

BeanFactory表示Bean工厂，所以很明显，BeanFactory会负责创建Bean，并且提供获取Bean的APl。
而ApplicationContext是BeanFactory的一种，在Spring源码中，是这么定义的：

```java
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver {
    ……
}
```

ApplicationContext继承了ListableBeanFactory和HierarchicalBeanFactory，而ListableBeanFactory和
HierarchicalBeanFactory都继承了BeanFactory，所以我们可以认为ApplicationContext继承了BeanFactory,
所以ApplicationContext也是BeanFactory的一种，拥有BeanFactory的所有功能。

不过ApplicationContext比BeanFactory更加强大，ApplicationContext还继承了其他接口，也就表示
ApplicationContext还拥有其他功能，比如MessageSource表示国际化，ApplicationEventPublisher表示事件发
布，EnvironmentCapable表示获取环境变量，等等，后面会马上介绍这些功能的使用。

在Spring的源码实现中，当我们new一个ApplicationContext时，其底层会new一个BeanFactory出来，当使用ApplicationContext的某些方法时，比如getBean()，底层调用的是BeanFactory的getBean()方法。

在Spring源码中，BeanFactory接口存在一个非常重要的实现类是：DefaultListableBeanFactory，也是非常核心的。具体重要性，随着后续课程会感受更深。

所以，我们也可以直接来使用DefaultListableBeanFactory：

```java
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        
        BeanDefinition beanDefinition = new AnnotatedGenericBeanDefinition(UserService.class);
        beanFactory.registerBeanDefinition("userService",beanDefinition);
        
        System.out.println(beanFactory.getBean("userService"));
```

#### 获取运行时环境变量

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);
        ConfigurableEnvironment environment = applicationContext.getEnvironment();

        System.out.println(environment.getSystemProperties());//jvm环境变量
        System.out.println(environment.getSystemEnvironment());//操作系统环境变量
        MutablePropertySources propertySources = environment.getPropertySources();
        for (PropertySource<?> propertySource : propertySources) {
            //1.jvm环境变量 2.操作系统环境变量 3.自定义环境变量
            System.out.println(propertySource);
        }

        UserService userService = (UserService)applicationContext.getBean("userService");
        userService.test();
```



#### 国际化

先定义一个MessageSource:

```java
@Bean
    public MessageSource messageSource(){
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("message");
        return messageSource;
    }
```

有了这个Bean，你可以在你任意想要进行国际化的地方使用该MessageSource。
同时，因为ApplicationContext也拥有国家化的功能，所以可以直接这么用：

```java
 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);
        System.out.println(applicationContext.getMessage("name",null, Locale.ENGLISH));
        System.out.println(applicationContext.getMessage("name",null,Locale.getDefault()));
```

#### 资源加载

ApplicationContext还拥有资源加载的功能，比如，可以直接利用ApplicationContext获取某个文件的内容：

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);

        Resource resource = applicationContext.getResource("classpath:application.properties");
        System.out.println(resource.contentLength());
```

也可以直接获取某个远程的资源

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);

Resource resource = applicationContext.getResource("https://www.baidu.com");
System.out.println(resource.contentLength());
System.out.println(resource.getURL());
```

还可以一次性获取多个

```java
Resource[] resources = context.getResources("classpath:com/wyy/*.class");
for(Resource resource:resources){
System.out.println(resource.contentLength());
System.out.println(resource.getFilename());
```

#### 事件发布

先定义一个事件监听器

```java
@Bean
    public ApplicationListener<PayloadApplicationEvent<String>> applicationEventApplicationListener(){
        return new ApplicationListener<PayloadApplicationEvent<String>>() {
            @Override
            public void onApplicationEvent(PayloadApplicationEvent<String> event) {
                System.out.println("接收事件："+event.getPayload());
            }
        };
    }
```

然后发布一个事件

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);

applicationContext.publishEvent("hello event");
```



### 类型转化

在Spring、SpringBoot、Spring Cloud中，有时根据beanName得到的Bean对象为A类型，但是需要的确实B类型，此时Spring就会找容器中是否有支持A类型转成B类型的类型转换器，如果有就会做类型转换，如果没有就会报错了。

#### PropertyEditor

这其实是JDK中提供的类型转化工具类，可以把一个String转成其他类型，比如一下自定义PropertyEditor就是支持把一个String转成User对象。

```java
public class StringToUserPropertyEditor extends PropertyEditorSupport {
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        User user = new User();
        user.setName(text);

        setValue(user);
    }
}
```



```java
StringToUserPropertyEditor propertyEditor = new StringToUserPropertyEditor();
propertyEditor.setAsText("wyy");
User user = (User)propertyEditor.getValue();
System.out.println(user.getName());
```

如何向Spring中注册PropertyEditor:

```java
@Bean
    public CustomEditorConfigurer customEditorConfigurer(){
        Map<Class<?>,Class<? extends PropertyEditor>> propertyEditorMap = new HashMap<>();
        propertyEditorMap.put(User.class,StringToUserPropertyEditor.class);

        //CustomEditorConfigurer是-个BeanFactoryPostProcessor
        CustomEditorConfigurer customEditorConfigurer = new CustomEditorConfigurer();
        customEditorConfigurer.setCustomEditors(propertyEditorMap);
        return customEditorConfigurer;
    }
```



```java
@Component
public class UserService {
    @Value("wyy")
    private User user;

    public void test(){
        System.out.println(user);
    }
}
```

Spring能自己把"wyy"这个字符串转成User对象。
Spring中内置了很多PropertyEditor，比如StringArrayPropertyEditor、PathEditor等。



#### ConversionService

PropertyEditor只能把String转成其他类型，而ConversionService则更强大。

```java
package com.wyy.studentmanager;

import org.springframework.core.convert.TypeDescriptor;
import org.springframework.core.convert.converter.ConditionalGenericConverter;

import java.util.Collections;
import java.util.Set;

public class StringToUserConverter implements ConditionalGenericConverter {
    @Override
    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        return sourceType.getType().equals(String.class) && targetType.getType().equals(User.class);
    }

    @Override
    public Set<ConvertiblePair> getConvertibleTypes() {
        return Collections.singleton(new ConvertiblePair(String.class,User.class));
    }

    @Override
    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
        User user = new User();
        user.setName((String)source);
        return user;
    }
}
```



```java
DefaultConversionService conversionService = new DefaultConversionService();
conversionService.addConverter(new StringToUserConverter());
User value = conversionService.convert("wyy",User.class);
System.out.println(value.getName());
```

```java
@Bean
    public ConversionServiceFactoryBean conversionServiceFactoryBean(){
        ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean();
        conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToUserConverter()));
        return  conversionServiceFactoryBean;
    }
```

```java
public class StringToUserConverter implements ConditionalGenericConverter {
    public StringToUserConverter() {
    }

    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        return sourceType.getType().equals(String.class) && targetType.getType().equals(User.class);
    }

    public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {
        return Collections.singleton(new GenericConverter.ConvertiblePair(String.class, User.class));
    }

    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
        User user = new User();
        user.setName((String)source);
        return user;
    }
}
```

```java
 @Bean
    public ConversionServiceFactoryBean conversionServiceFactoryBean() {
        ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean();
        conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToUserConverter()));
        return conversionServiceFactoryBean;
    }
```

#### TypeConvertor

整合了PropertyEditor和ConversionService的功能，Spring内部用的就是它

```java
DefaultConversionService conversionService = new DefaultConversionService();
conversionService.addconverter(new StringToUserConverter());
SimpleTypeConverter typeConverter = new SimpleTypeConverter();
typeConverter.registerCustomEditor(User.class, new StringToUserPropertyEditor());
typeConverter.setConversionService(conversionService);
User value = typeConverter.convertIfNecessary("wyy", User.class);
System.out.println(value.getName());
```



### OrderComparator和AnnotationAwareOrderComparator

OrderComparator是Spring所提供的一种比较器，会根据@Order注解或Ordered接口来进行比较，从而可以用来排序。

比如：

```java
public class A implements Ordered {
    @Override
    public int getOrder() {
        return 2;
    }
}
```

```java
public class B implements Ordered {
    @Override
    public int getOrder() {
        return 3;
    }
}
```

```java
public class StudentManagerApplication {

    public static void main(String[] args) throws IOException {
        List<Object> list = new ArrayList<>();
        list.add(new A());
        list.add(new B());

        //按order值升序排序
        list.sort(new OrderComparator());
        System.out.println(list);
    }

}
```

