[TOC]
```
2024-4-8
```
## 2009使数组连续的最小操作数
### 算法题目    


>给你一个整数数组 nums 。每一次操作中，你可以将 nums 中 任意 一个元素替换成 任意 整数。     
>如果 nums 满足以下条件，那么它是 连续的 ： 
>nums 中所有元素都是 互不相同 的。  
>nums 中 最大 元素与 最小 元素的差等于 nums.length - 1 。   
>比方说，nums = [4, 2, 5, 3] 是 连续的 ，但是 nums = [1, 2, 3, 5, 6] 不是连续的 。  
>请你返回使 nums 连续 的 最少 操作次数。    

*** 示例1 ***
> 输入：nums = [4,2,5,3]    
> 输出：0   
> 解释：nums 已经是连续的了。     

*** 示例2 ***
> 输入：nums = [1,2,3,5,6]  
> 输出：1   
> 解释：一个可能的解是将最后一个元素变为 4 。   
> 结果数组为 [1,2,3,5,4] ，是连续数组。   

*** 示例3 ***
> 输入：nums = [1,10,100,1000]  
> 输出：3   
> 解释：一个可能的解是：    
> - 将第二个元素变为 2 。
> - 将第三个元素变为 3 。
> - 将第四个元素变为 4 。
> 结果数组为 [1,2,3,4] ，是连续数组。

### 滑动窗口
#### 1.算法介绍
在计算机网络中，滑动窗口协议（Sliding Window Protocol）是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。我们所要讲解的滑动窗口算法也是利用了同样的特性。 
>滑动窗口（Sliding Window）：在给定数组 / 字符串上维护一个固定长度或不定长度的窗口。可以对窗口进行滑动操>作、缩放操作，以及维护最优解操作。 
+ 滑动操作：窗口可按照一定方向进行移动。最常见的是向右侧移动。
+ 缩放操作：对于不定长度的窗口，可以从左侧缩小窗口长度，也可以从右侧增大窗口长度。
*** 滑动窗口利用了双指针中的快慢指针技巧，我们可以将滑动窗口看做是快慢指针两个指针中间的区间，也可以可以将滑动窗口看做是快慢指针的一种特殊形式。 ***
#### 2.适用范围
滑动窗口算法一般用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。该算法可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。     
根据问题，我们可以将滑动窗口分为以下两种：      

*** 固定长度窗口 ***：窗口大小是固定的。    
*** 不定长度窗口 ***：窗口大小是不固定的。  
+ 求解最大的满足条件的窗口。
+ 求解最小的满足条件的窗口。
#### 3.固定长度窗口
##### 3.1固定长度窗口求解步骤
假设窗口的固定大小为 window_size。

1. 使用两个指针 left、right。初始时，left 、right 都指向序列的第一个元素，即：left = 0，right = 0 ，区间 [left, right] 被称为一个「窗口」。
2. 当窗口未达到 window_size 大小时，不断移动 right，先将 window_size 个元素填入窗口中。
3. 当窗口达到window_size大小时，判断窗口内的连续元素是否满足题目限定的条件。
    1. 如果满足，再根据要求更新最优解。
    2. 然后向右移动 left，从而缩小窗口长度，即 left += 1，使得窗口大小始终保持为 window_size。
4. 向右移动 right，将元素填入窗口中。
5. 重复 2 ~ 4 步，直到 right 到达序列末尾。
#### 4.不定长度窗口
##### 4.1 不定长度窗口求解步骤
+ 使用两个指针 left、right。初始时，left、right 都指向序列的第一个元素。即：left = 0，right = 0，区间 [left, right] 被称为一个「窗口」。
+ 将区间最右侧元素添加入窗口中，即 window.add(s[right])。
+ 然后向右移动 right，从而增大窗口长度，即 right += 1。直到窗口中的连续元素满足要求。
+ 此时，停止增加窗口大小。转向不断将左侧元素移出窗口，即 window.popleft(s[left])。
+ 然后向右移动 left，从而缩小窗口长度，即 left += 1。直到窗口中的连续元素不再满足要求。
重复 2 ~ 5 步，直到 right 到达序列末尾。
### 算法实现
+ 记数组 nums 的长度为 n。
+ 经过若干次操作后，若数组变为连续的，那么数组的长度不会改变，仍然为 n，且数组最大值与最小值之差为 n−1，所有元素均不相同。  
+ 可以反向考虑，假设最后连续的数组的最小值为 left，则最大值 right = left + n - 1。
+ 原数组 nums 中，如果有位于 [left,right]中的，如果只出现一次，我们可以对其进行保留；多次出现时，我们则需要对其进行操作；不在这个区间的数字，我们也需要对其进行操作，将它们变成其他数字来对这个区间进行补足。因此，我们需要统计原数组 nums中，位于区间 [left,right]内不同的数字个数 k，而 n−k 就是我们需要进行的操作数。
+ 接下来就是需要确定 left，我们可以将原数组 nums 所有不同的数字作为 left的候选值，分别计算出 n−k，然后求出最小值。这样的话，我们可以先将原数字进行去重后排序，然后利用滑动窗口。滑动窗口左端点的值作为 left，然后向右扩展右端点，窗口的长度即为 k，求出所有可能性下最小的 n−k即可。

```c++
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        int res = n, j = 0;
        for (int i = 0; i < nums.size(); i++) {
            int right = nums[i] + n - 1;
            while (j < nums.size() && nums[j] <= right) {
                res = min(res, n - (j - i + 1));
                j++;
            }
        }            
        return res;
    }
};
```
```java
class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        Set<Integer> set = new HashSet<Integer>();
        for(int num:nums){
            set.add(num);
        }
        List<Integer> list = new ArrayList<Integer>(set);
        Collections.sort(list);
        int res = n;
   }
}
```



