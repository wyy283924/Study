[TOC]
## 3010.将数组分成最小总代价的数组

```
2024-5-28
```
### 题目描述
```
给你一个长度为 n 的整数数组 nums 。                     

一个数组的 代价 是它的 第一个 元素。比方说，[1,2,3] 的代价是 1 ，[3,4,1] 的代价是 3 。                              

你需要将 nums 分成 3 个 连续且没有交集 的子数组。                   

请你返回这些
子数组
的 最小 代价 总和 。                                                                                                                                                
```

*** 示例1 ***
> 输入：nums = [1,2,3,12]                                   
> 输出：6                                                       
> 解释：最佳分割成 3 个子数组的方案是：[1] ，[2] 和 [3,12] ，总代价为 1 + 2 + 3 = 6 。                          
其他得到 3 个子数组的方案是：                               
- [1] ，[2,3] 和 [12] ，总代价是 1 + 2 + 12 = 15 。
- [1,2] ，[3] 和 [12] ，总代价是 1 + 3 + 12 = 16 。                                                                                       

        
*** 示例2 ***
> 输入：nums = [5,4,3]                                                                                                           
> 输出：12                                   
> 解释： 最佳分割成 3 个子数组的方案是：[5] ，[4] 和 [3] ，总代价为 5 + 4 + 3 = 12 。                           
12 是所有分割方案里的最小总代价。                                         
 
### 思路          

把数组分成三段，每一段取第一个数再求和，问和的最小值是多少。                    

第一段的第一个数是确定的，即 nums[0]。                      

如果知道了第二段的第一个数的位置，和第三段的第一个数的位置，那么这个划分方案也就确定了。                            

这两个下标可以在 [1,n−1] 中随意取。                         

所以问题变成求下标在 [1,n−1] 中的两个最小的数。                 

### 实现
```java
class Solution {
    public int minimumCost(int[] nums) {
        int first = nums[0];
        int second = 50;
        int last = 50;
        for(int i = 1; i < nums.length; i ++){
        if(nums[i] < second){
                last = second;
                second = nums[i];
            }else if(nums[i] < last){
                last = nums[i];
            }
        }
        return first+second+last;
    }

}
```