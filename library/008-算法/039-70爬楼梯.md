[TOC]
## 70.爬楼梯

```
2024-5-16
```
### 题目描述
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。     

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？        
```
*** 示例1 ***
> 输入：n = 2   
> 输出：2                         
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶               
        
*** 示例2 ***
> 输入：n = 3         
> 输出：3           
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶                       
 
### 思路          

我们要解决的问题是从 0 爬到 n 有多少种不同的方法。          

分类讨论：          

如果最后一步爬了 1 个台阶，那么我们得先爬到 8，要解决的问题缩小成：从 0 爬到 n-1 有多少种不同的方法。             

如果最后一步爬了 2 个台阶，那么我们得先爬到 7，要解决的问题缩小成：从 0 爬到 n-2 有多少种不同的方法。         
由于这两种情况都会把原问题变成一个和原问题相似的、规模更小的子问题，所以可以用递归解决。 

```
f(i)=f(i−1)+f(i−2)
```
观察状态转移方程，发现一旦算出 f[i]，那么 f[i−2]及其左边的状态就永远不会用到了。          
这意味着每次循环，只需要知道「上一个状态」和「上上一个状态」的 f值是多少，分别记作 f1和f0
。它俩的初始值均为 1，对应着 f[1]和 f[0]。

每次循环，计算出新的状态 newF=f1+f0，那么对于下一轮循环来说：                               

「上上一个状态」就是 f1，更新 f0=f1。
「上一个状态」就是 newF，更新 f1=newF。最后答案为 f1，因为最后一轮循环算出的 newF\赋给了 f1         
### 实现
```java
class Solution {
    public int climbStairs(int n) {
        int f0 = 1,f1 = 1;
        for(int i  = 2; i <= n; i ++){
            int newF = f1+f0;
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
```