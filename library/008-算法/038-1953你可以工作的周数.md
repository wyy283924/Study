[TOC]
## 1953.你可以工作的周数

```
2024-5-15
```
### 题目描述
```
给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。

你可以按下面两个规则参与项目中的工作：

每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。

返回在不违反上面规则的情况下你 最多 能工作多少周。
```
*** 示例1 ***
> 输入：milestones = [1,2,3]   
> 输出：6                         
> 解释：一种可能的情形是：
​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。        
- 第 2 周，你参与并完成项目 2 中的一个阶段任务。        
- 第 3 周，你参与并完成项目 1 中的一个阶段任务。        
- 第 4 周，你参与并完成项目 2 中的一个阶段任务。        
- 第 5 周，你参与并完成项目 1 中的一个阶段任务。        
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。            
总周数是 6 。               
        
*** 示例2 ***
> 输入：milestones = [5,2,1]         
> 输出：7           
> 解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。        
- 第 2 周，你参与并完成项目 1 中的一个阶段任务。    
- 第 3 周，你参与并完成项目 0 中的一个阶段任务。    
- 第 4 周，你参与并完成项目 1 中的一个阶段任务。    
- 第 5 周，你参与并完成项目 0 中的一个阶段任务。    
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。    
- 第 7 周，你参与并完成项目 0 中的一个阶段任务。    
总周数是 7 。   
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。                       
 
### 思路
本质上来说，我们需要构造一个尽量长的，相邻元素不同的序列，且元素 x 的出现次数不能超过 milestones[x]。       

示例 1 可以构造的一个序列是 [2,1,2,1,2,0]。     
示例 2 可以构造的一个序列是 [0,1,0,1,0,2,0]。       
设 milestones 的元素和为 s，这是序列长度的上界。示例 1 可以构造长为 s=6 的序列，但示例 2 不行。看上去，如果有一个 milestones[i] 特别大，我们就没法构造出一个长为 s 的序列了。这个数具体要多大呢？                    

想一想，一个长为 k 的序列，至多可以有多少个相同元素？                        

设 m=max⁡(milestones)。假设 milestones[2]=m。           
如果序列长度是奇数，我们可以在偶数下标 0,2,4,⋯ ,k−10上放置元素 2。假设还可以放一个 2，那么它必然会和另一个 2 相邻。例如 k=7，我们可以在偶数下标 0,2,4,60 上放置 2，奇数下标 1,3,5 只能放其它元素。这也说明，序列中元素 2 的个数至多比其它元素的个数之和多 1。           
如果序列长度是偶数，我们可以在偶数下标 0,2,4,⋯ ,k−2上放置元素 2，奇数下标放其它元素。如果还有 2，我们可以在序列末尾再加一个 2，转换成序列长度是奇数的情况。         
一般地，如果有一个 milestones[i]=m 特别大，大到它比其它元素的个数之和加 1 还要大，即 m>s−m+1，那么序列长度将会以其它元素的个数之和为主，即 2⋅(s−m)+1。例如示例 2，s−m=3，序列长度为 2⋅3+1=7，在偶数下标放元素 0，奇数下标放其它元素。       

剩下要解决的问题是，如果 m≤s−m+1，是否一定可以构造一个长为 sss 的序列？

可以，构造方法如下：        

把 milestones从大到小排序。以 milestones=[3,3,2] 为例，s=3+3+2=8。按照先填偶数下标，再填奇数下标，也就是下标 0,2,4,6,1,3,5,7的顺序，首先填入三个元素 0，得到        

0,_,0,_,0,_,_,_

继续按照顺序，填入三个元素 1，得到

0,1,0,1,0,_,1,_     
最后填入两个元素 2，得到

0,1,0,1,0,2,1,2         
按照该构造方法，如果出现两个相邻元素相同的情况，那么它不会是从奇数下标开始填的（这样不会出现相邻相同），而是从某个偶数下标开始填的，然后在填到某个奇数下标时，出现了相邻元素相同的情况，例如下标顺序为 4,6,1,3，该元素出现次数至少为 4。但是，由于我们已经把 milestones从大到小排序了，4必然是最大值，不可能从偶数下标 4开始，只能从偶数下标 0 开始（注意不能从奇数下标开始），即 0,2,4,6,10,2,4,6,10,2,4,6,1，这意味着该元素至少出现 555 次，但 5>8−5+1，与 m≤s−m+1的前提不符。        

综上所述：

如果 m>s−m+1，返回 2⋅(s−m)+1。                   
如果 m≤s−m+1，返回 s。          
### 实现
```java
class Solution {
    public long numberOfWeeks(int[] milestones) {
        long s = 0;
        int m = 0;
        for (int x : milestones) {
            s += x;
            m = Math.max(m, x);
        }
        return m > s - m + 1 ? (s - m) * 2 + 1 : s;
    }

}
```